    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Retro Library</title>
    
</head>
<body>

    <div id="crt-container">
        <canvas id="crt-canvas"></canvas>
    </div>

    <script type="importmap">
    {
      "imports": {
        "regl": "https://cdn.skypack.dev/regl",
        "gl-matrix": "https://cdn.skypack.dev/gl-matrix"
      }
    }
    </script>
    <script type="module">
        import regl from 'regl';
        import { mat4 } from 'gl-matrix';

        const canvas = document.getElementById('crt-canvas');
        const dpr = window.devicePixelRatio || 1;
        const canvasWidth = 800;
        const canvasHeight = 600;
        canvas.width = canvasWidth * dpr;
        canvas.height = canvasHeight * dpr;
        canvas.style.width = `${canvasWidth}px`;
        canvas.style.height = `${canvasHeight}px`;

        const reg = regl(canvas);

        const uiCanvas = document.createElement('canvas');
        uiCanvas.width = canvasWidth * dpr;
        uiCanvas.height = canvasHeight * dpr;
        const ctx = uiCanvas.getContext('2d');
        const uiTexture = reg.texture(uiCanvas);

        let searchInput = '';
        let books = [];
        let status = 'Enter a search term and press Enter.';
        let inputActive = true;
        let scrollY = 0;
        let maxScroll = 0;
        const bookHeight = 60 * dpr;
        const padding = 15 * dpr;

        document.addEventListener('keydown', (e) => {
            if (!inputActive) return;

            if (e.key === 'Enter') {
                e.preventDefault();
                if (searchInput.trim() !== '') {
                    searchBooks(searchInput.trim());
                }
            } else if (e.key === 'Backspace') {
                searchInput = searchInput.slice(0, -1);
            } else if (e.key.length === 1) { // Regular character input
                searchInput += e.key;
            }
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            scrollY += e.deltaY * 0.5;
            if (scrollY < 0) scrollY = 0;
            if (scrollY > maxScroll) scrollY = maxScroll;
        });

        async function searchBooks(query) {
            status = `Searching for "${query}"...`;
            inputActive = false;
            books = [];
            scrollY = 0;
            maxScroll = 0;
            try {
                const response = await fetch(`https://www.googleapis.com/books/v1/volumes?q=${encodeURIComponent(query)}&maxResults=20`);
                if (!response.ok) {
                    throw new Error('Network response was not ok');
                }
                const data = await response.json();
                if (data.items) {
                    books = data.items.map(item => ({
                        title: item.volumeInfo.title,
                        authors: item.volumeInfo.authors ? item.volumeInfo.authors.join(', ') : 'Unknown Author',
                        cover: item.volumeInfo.imageLinks?.thumbnail
                    }));
                    status = `Results for "${query}". Scroll with mouse wheel.`;
                    maxScroll = Math.max(0, books.length * bookHeight - (uiCanvas.height - 100 * dpr));
                } else {
                    status = `No results found for "${query}".`;
                }
            } catch (error) {
                console.error('Search failed:', error);
                status = 'Error fetching books. Try again.';
            } finally {
                inputActive = true;
            }
        }

        function drawUI() {
            const w = uiCanvas.width;
            const h = uiCanvas.height;

            // Clear
            ctx.fillStyle = '#020a0a';
            ctx.fillRect(0, 0, w, h);
            ctx.strokeStyle = '#00ff00';
            ctx.lineWidth = 2 * dpr;

            // Header
            ctx.font = `${18 * dpr}px 'Inconsolata', monospace`;
            ctx.fillStyle = '#00ff00';
            ctx.textAlign = 'center';
            ctx.fillText('=== RETRO BOOK FINDER ===', w / 2, 30 * dpr);

            // Search Box
            ctx.textAlign = 'left';
            ctx.fillText('Search:', padding, 60 * dpr);
            ctx.strokeRect(padding + 90 * dpr, 45 * dpr, w - padding * 2 - 90 * dpr, 25 * dpr);
            ctx.fillText(searchInput, padding + 95 * dpr, 62 * dpr);

            // Cursor
            if (inputActive && Math.floor(performance.now() / 500) % 2) {
                const textWidth = ctx.measureText(searchInput).width;
                ctx.fillRect(padding + 95 * dpr + textWidth, 47 * dpr, 10 * dpr, 20 * dpr);
            }

            // Status Line
            ctx.textAlign = 'center';
            ctx.font = `${12 * dpr}px 'Inconsolata', monospace`;
            ctx.fillText(status, w / 2, 85 * dpr);
            
            // Results
            ctx.save();
            ctx.beginPath();
            ctx.rect(0, 100 * dpr, w, h - 100 * dpr);
            ctx.clip();
            
            ctx.translate(0, -scrollY);

            ctx.textAlign = 'left';
            ctx.font = `${14 * dpr}px 'Inconsolata', monospace`;
            books.forEach((book, index) => {
                const y = 100 * dpr + index * bookHeight;
                ctx.fillStyle = '#00dd00';
                
                let title = book.title;
                if(title.length > 50) title = title.substring(0, 47) + '...';

                ctx.fillText(`> ${title}`, padding, y + 25 * dpr);
                ctx.fillStyle = '#00aa00';
                ctx.font = `${12 * dpr}px 'Inconsolata', monospace`;
                ctx.fillText(`  by ${book.authors}`, padding, y + 45 * dpr);
                ctx.font = `${14 * dpr}px 'Inconsolata', monospace`;
            });
            ctx.restore();
            
            uiTexture.subimage(uiCanvas);
        }

        const drawCRT = reg({
            frag: `
            precision mediump float;
            uniform sampler2D u_texture;
            uniform float u_time;
            uniform vec2 u_resolution;
            varying vec2 v_uv;

            // Bend effect
            vec2 bend(vec2 uv) {
                float bendFactor = 0.15;
                uv -= 0.5;
                uv.x *= 1.0 + pow(abs(uv.y), 2.0) * bendFactor;
                uv.y *= 1.0 + pow(abs(uv.x), 2.0) * bendFactor;
                return uv + 0.5;
            }

            void main() {
                vec2 bent_uv = bend(v_uv);

                // Chromatic Aberration
                float ca_amount = 0.003;
                float r = texture2D(u_texture, bent_uv + vec2(ca_amount, 0.0)).r;
                float g = texture2D(u_texture, bent_uv).g;
                float b = texture2D(u_texture, bent_uv - vec2(ca_amount, 0.0)).b;

                vec3 color = vec3(r, g, b);
                
                // Scanlines
                float scanline_intensity = 0.15;
                float scanline = sin(bent_uv.y * u_resolution.y * 1.2) * scanline_intensity;
                color -= scanline;

                // Vignette
                float vignette = length(bent_uv - 0.5);
                color *= 1.0 - pow(vignette, 2.5);

                // Flicker
                color *= 1.0 - (sin(u_time * 10.0) * 0.01);
                
                if (bent_uv.x < 0.0 || bent_uv.x > 1.0 || bent_uv.y < 0.0 || bent_uv.y > 1.0) {
                    gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);
                } else {
                    gl_FragColor = vec4(color, 1.0);
                }
            }`,
            vert: `
            precision mediump float;
            attribute vec2 a_position;
            varying vec2 v_uv;
            void main() {
                v_uv = 0.5 * (a_position + 1.0);
                v_uv.y = 1.0 - v_uv.y; // Flip Y
                gl_Position = vec4(a_position, 0, 1);
            }`,
            attributes: {
                a_position: [[-1, -1], [1, -1], [-1, 1], [1, 1], [-1, 1], [1, -1]]
            },
            uniforms: {
                u_texture: uiTexture,
                u_time: ({ time }) => time,
                u_resolution: [canvas.width, canvas.height]
            },
            count: 6
        });
        
        reg.frame(() => {
            reg.clear({ color: [0, 0, 0, 1] });
            drawUI();
            drawCRT();
        });

    </script>
</body>
</html>